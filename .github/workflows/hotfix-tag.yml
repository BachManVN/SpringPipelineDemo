name: '[Release] Create Hotfix Tag'
run-name: |
  ${{ format('[Release] Create Hotfix Tag - Hotfix branch push by {0}', github.actor) }}

# CRITICAL: This is the ONLY place hotfix tags are created
# WHY: CI must be the only tag creator to ensure consistency and prevent conflicts
# Humans must NOT create hotfix tags directly
#
# HOTFIX WORKFLOW:
# 1. Checkout an older release tag (e.g., v1.4.0 when latest is v1.6.0)
# 2. Create fix branch: git checkout v1.4.0 && git checkout -b fix-bug-1.4.0
# 3. Make fixes, test on SIT, then create PR: fix-bug-1.4.0 ‚Üí hotfix
# 4. When PR is merged to hotfix branch, this workflow triggers
# 5. Workflow detects base tag (v1.4.0) and creates hotfix tag (v1.4.1)
# 6. Deploy hotfix tag to UAT: git checkout v1.4.1 && ./bin/deploy.sh uat
# 7. After UAT testing, create PR: uat ‚Üí prod
#
# Branch role: hotfix is a PR-gated tag creation branch (pointer branch, not code source)

on:
  push:
    branches:
      - hotfix

env:
  JAVA_VERSION: '17'

jobs:
  create-hotfix-tag:
    name: Create Hotfix Tag
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to create tags
      id-token: write  # Required for Azure authentication if needed
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for tag detection
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'

      - name: Fetch all tags
        run: |
          echo "üì• Fetching all tags from remote..."
          git fetch --tags --force
          echo "‚úÖ Tags fetched"

      - name: Verify hotfix branch requirements
        run: |
          echo "üîç Verifying hotfix branch requirements..."
          echo "   WHY: hotfix branch is PR-gated - tags are only created after PR merge"
          
          # Ensure we're on hotfix branch
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          if [ "$CURRENT_BRANCH" != "hotfix" ]; then
            echo "‚ùå ERROR: This workflow should only run on 'hotfix' branch"
            exit 1
          fi
          
          # CRITICAL: Find the base tag for hotfix version calculation
          # WHY: Hotfix tags increment patch version from base tag (v1.4.0 ‚Üí v1.4.1)
          # Strategy: Find the nearest semantic version tag that is an ancestor of current commit
          # This works even after PR merge because git describe finds the tag in history
          BASE_TAG=$(git describe --tags --abbrev=0 HEAD 2>/dev/null || echo "")
          
          # If no tag found, try parent commits (in case of merge commits)
          if [ -z "$BASE_TAG" ]; then
            for i in {1..10}; do
              BASE_TAG=$(git describe --tags --abbrev=0 HEAD~$i 2>/dev/null || echo "")
              if [ -n "$BASE_TAG" ]; then
                break
              fi
            done
          fi
          
          # Validate base tag exists and has correct format
          if [ -z "$BASE_TAG" ]; then
            echo "‚ùå ERROR: Cannot determine base tag for hotfix"
            echo "   WHY: Hotfix tags must be based on an existing semantic version tag"
            echo "   Workflow: Checkout old tag (e.g., v1.4.0) ‚Üí create fix-bug-1.4.0 ‚Üí PR to hotfix"
            echo ""
            echo "   Available tags:"
            git tag -l "v[0-9]*.[0-9]*.[0-9]*" | sort -V | tail -10 || echo "   (No tags found)"
            exit 1
          fi
          
          # Validate tag format
          if [[ ! "$BASE_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ùå ERROR: Base tag must be semantic version format: $BASE_TAG"
            echo "   WHY: Only semantic version tags (vX.Y.Z) can be used as hotfix base"
            echo "   Expected format: v1.4.0, v2.0.0, etc."
            exit 1
          fi
          
          echo "‚úÖ Base tag found: $BASE_TAG"
          echo "   WHY: Hotfix will increment patch version from this base tag"
          
          # Calculate next version for display
          if [[ "$BASE_TAG" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            PATCH="${BASH_REMATCH[3]}"
            NEXT_PATCH=$((PATCH + 1))
            echo "   Example: $BASE_TAG ‚Üí v${MAJOR}.${MINOR}.${NEXT_PATCH}"
          fi
          
          echo "BASE_TAG=$BASE_TAG" >> $GITHUB_ENV

      - name: Determine next hotfix version
        id: version
        run: |
          echo "üîç Determining next hotfix version..."
          echo "   WHY: Auto-calculate next patch version to prevent conflicts"
          
          BASE_TAG="${{ env.BASE_TAG }}"
          
          # CRITICAL: Extract version components from base tag (e.g., v1.4.0)
          # WHY: Hotfix increments patch version automatically (v1.4.0 ‚Üí v1.4.1)
          if [[ "$BASE_TAG" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            PATCH="${BASH_REMATCH[3]}"
            
            # CRITICAL: Hotfix increments patch version: v1.4.0 ‚Üí v1.4.1
            # WHY: Patch version bump indicates hotfix (backward-compatible bug fix)
            NEW_PATCH=$((PATCH + 1))
            HOTFIX_TAG="v${MAJOR}.${MINOR}.${NEW_PATCH}"
          else
            echo "‚ùå ERROR: Invalid base tag format: $BASE_TAG"
            echo "   Expected format: vX.Y.Z (e.g., v1.4.0)"
            exit 1
          fi
          
          # CRITICAL: Check if tag already exists to prevent duplicate tags
          # WHY: Duplicate tags cause deployment confusion and conflicts
          if git rev-parse "$HOTFIX_TAG" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Tag $HOTFIX_TAG already exists, checking for conflicts..."
            # If tag exists and points to different commit, error
            EXISTING_COMMIT=$(git rev-parse "$HOTFIX_TAG")
            CURRENT_COMMIT=$(git rev-parse HEAD)
            if [ "$EXISTING_COMMIT" != "$CURRENT_COMMIT" ]; then
              echo "‚ùå ERROR: Tag $HOTFIX_TAG already exists and points to different commit"
              echo "   WHY: Duplicate tags pointing to different commits cause deployment conflicts"
              echo "   Existing: $EXISTING_COMMIT"
              echo "   Current:  $CURRENT_COMMIT"
              exit 1
            else
              echo "‚úÖ Tag $HOTFIX_TAG already exists and points to current commit"
              echo "   WHY: Tag already created, skipping duplicate creation"
              echo "hotfix_tag=$HOTFIX_TAG" >> $GITHUB_OUTPUT
              echo "tag_exists=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          echo "‚úÖ Hotfix tag: $HOTFIX_TAG (from base $BASE_TAG)"
          echo "   WHY: Auto-calculated patch version increment for hotfix"
          echo "hotfix_tag=$HOTFIX_TAG" >> $GITHUB_OUTPUT
          echo "tag_exists=false" >> $GITHUB_OUTPUT

      - name: Create hotfix tag
        if: steps.version.outputs.tag_exists != 'true'
        run: |
          HOTFIX_TAG="${{ steps.version.outputs.hotfix_tag }}"
          COMMIT_SHA="${{ github.sha }}"
          COMMIT_MSG=$(git log -1 --pretty=%B)
          
          echo "üè∑Ô∏è  Creating hotfix tag: $HOTFIX_TAG"
          echo "   WHY: Use annotated tags for rich metadata (author, date, message)"
          echo "   Commit: $COMMIT_SHA"
          echo "   Message: $COMMIT_MSG"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # CRITICAL: Create annotated tag (not lightweight)
          # WHY: Annotated tags store metadata (author, date, message) and are better for releases
          # WHY: Annotated tags are required for git describe --exact-match to work reliably
          git tag -a "$HOTFIX_TAG" -m "Hotfix $HOTFIX_TAG
          
          Commit: $COMMIT_SHA
          Message: $COMMIT_MSG
          
          Base tag: ${{ env.BASE_TAG }}
          
          Base tag: ${{ env.BASE_TAG }}
          
          This hotfix tag was automatically created after PR merge to hotfix branch.
          Workflow: fix-bug-<version> branch ‚Üí PR to hotfix ‚Üí auto-tag creation
          WHY: CI must be the only tag creator to ensure consistency."
          
          # Push tag to remote
          git push origin "$HOTFIX_TAG"
          
          echo "‚úÖ Hotfix tag created and pushed: $HOTFIX_TAG"
          echo "   WHY: Tag is now available for deployment to UAT"

      - name: Tag creation summary
        if: always()
        run: |
          if [ "${{ steps.version.outputs.tag_exists }}" = "true" ]; then
            echo "‚ÑπÔ∏è  Tag ${{ steps.version.outputs.hotfix_tag }} already exists"
          else
            echo "‚úÖ Successfully created hotfix tag: ${{ steps.version.outputs.hotfix_tag }}"
            echo "   Base tag: ${{ env.BASE_TAG }}"
            echo ""
            echo "   Next steps:"
            echo "   1. Deploy to UAT:"
            echo "      git checkout ${{ steps.version.outputs.hotfix_tag }}"
            echo "      ./bin/deploy.sh uat"
            echo ""
            echo "   2. After UAT testing, create PR: uat ‚Üí prod"
          fi
